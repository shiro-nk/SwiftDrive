package sd.swiftclient.rk.nk;

import java.io.Closeable;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;

import sd.swiftglobal.rk.Settings;
import sd.swiftglobal.rk.expt.DisconnectException;
import sd.swiftglobal.rk.expt.FileException;
import sd.swiftglobal.rk.type.Data;
import sd.swiftglobal.rk.type.SwiftFile;
import sd.swiftglobal.rk.util.Logging;
import sd.swiftglobal.rk.util.Ping;
import sd.swiftglobal.rk.util.SwiftNet.SwiftNetContainer;
import sd.swiftglobal.rk.util.SwiftNet.SwiftNetTool;

/* This file is part of Swift Drive				   *
 * Copyright (C) 2015 Ryan Kerr                    *
 * Please refer to <http://www.gnu.org/licenses/>. */

/**
 * Client side of the data transfer network.
 *
 * @author Ryan Kerr
 */
public class Client extends Thread implements SwiftNetTool, Settings, Logging, Closeable, Runnable {
	
	private final Socket server;
	private DataInputStream  dis;
	private DataOutputStream dos;
	private boolean online = false;
	private Ping ping;
	
	/**
	 * Establishes a connecting and I/O sockets with the server
	 * @param hostname Host to connect to
	 * @param port Host port
	 * @throws DisconnectException If something fails while connecting
	 */
	public Client(String hostname, int port) throws DisconnectException {
		try {
			server = new Socket(hostname, port);
			dis = new DataInputStream(server.getInputStream());
			dos = new DataOutputStream(server.getOutputStream());
			online = true;
		}
		catch(IOException ix) {
			online = false;
			throw new DisconnectException(EXC_CONN);
		}
	}
	
	public void run() {
		try {
			while(online) {
				if(ping == null) {
					ping = new Ping(dis, dos, this);
					new Thread(ping).start();
				}
			}
		}
		catch(Exception ex) {
			ex.printStackTrace();
		}
		
		System.out.println("CLIENT CLOSED");
	}
	
	public Data receiveData(Data template) throws DisconnectException {
		ping.deactivate();
		template.reset();
		try {
			int size = dis.readInt();
			for(int i = 0; i < size; i++) template.add(dis.readUTF());
			ping.activate();
			return template;
		}
		catch(IOException ix) {
			kill();
			throw new DisconnectException(EXC_NREAD, ix);
		}
	}
	
	public <Type extends Data> void sendData(Type data) throws DisconnectException {
		try {
			dos.writeInt(Type.getTypeID());
			dos.writeInt(data.getSize());
			for(String s : data.getArray()) dos.writeUTF(s);
		}
		catch(IOException ix) {
			kill();
			throw new DisconnectException(EXC_CONN, ix);
		}
	}
	
	public SwiftFile getFile() throws DisconnectException {
		try {
			return new SwiftFile(dis);
		}
		catch(IOException ix) {
			kill();
			throw new DisconnectException(EXC_CONN, ix);
		}
	}
	
	public void sendFile(SwiftFile file) throws DisconnectException, FileException {
		try {
			file.send(dos);
		}
		catch(IOException ix) {
			kill();
			throw new DisconnectException(EXC_CONN, ix);
		}
	}
	
	public void disconnect() throws DisconnectException {
		try {
			dos.writeInt(DAT_NULL);
		}
		catch(IOException ix) {
			kill();
			throw new DisconnectException(EXC_WRITE, ix);
		}
	}
	
	public int getID() {
		return 0;
	}
	
	public void setParent(SwiftNetContainer c) {
		
	}
	
	public SwiftNetContainer getParent() {
		return null;
	}
	
	public void kill() {
		System.err.println("Kill call made to client");
	}
	
	public void close() {
		try {
			if(dis != null) dis.close();
			if(dos != null) dos.close();
			if(server != null) server.close();
			online = false;
		}
		catch(IOException ix) {
			error("Error closing sockets", LOG_FRC);
		}
	}
}
